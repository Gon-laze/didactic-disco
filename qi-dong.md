# 启动

对很多初次分析操作系统代码的人来说，能按照启动顺序一步步来分析整个系统是再好不过的解决方案。但有一件非常糟心的事：找到整个系统的入口同样不轻松！

## 内核链接

毫无疑问，操作系统的内核是寻找运行轨迹的突破口。当`make`指令尝试生成内核的时候，它需要用到两个依赖项：`kernel/kernel.ld`以及`user/initcode`。两个文件都非常重要：前者指定了riscv指令架构、内存体系，并提供了更进一步的入口`ENTRY()`；后者可以进行一个初始化工作，并为后续用户做准备。

`kernel/kernel.ld`规定了几个比较重要的规则：首先，它把程序的入口设为了`_entry`，一个由`kernel/entry.S`编译而成的程序文件；接着，这个链接文件将设置本系统的几个关键变量，如**0x80000000**，`etext`以及`end`等，这几个量会在之后的内存管理/分配中起到重大的作用。

## Bootloader——entry

作为链接文件的指定入口，`_entry`的工作为加载内核

{% hint style="info" %}
对于x86，开机时同样会启动引导程序。它的bootloader将会被复制到0x7c00处，然后bootloader开始进行内核的复制与运行。在这一方面，x86和riscv基本等同。
{% endhint %}

